<?php
/**
 * RouteManeuver
 *
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Stadia Maps Geospatial APIs
 *
 * The Stadia Maps Geospatial APIs provide you with the data you need to build awesome applications.
 *
 * The version of the OpenAPI document: 6.5.0
 * Contact: support@stadiamaps.com
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.7.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Model;

use \ArrayAccess;
use \OpenAPI\Client\ObjectSerializer;

/**
 * RouteManeuver Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class RouteManeuver implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'routeManeuver';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'type' => 'int',
        'instruction' => 'string',
        'verbal_transition_alert_instruction' => 'string',
        'verbal_pre_transition_instruction' => 'string',
        'verbal_post_transition_instruction' => 'string',
        'street_names' => 'string[]',
        'begin_street_names' => 'string[]',
        'time' => 'float',
        'length' => 'float',
        'begin_shape_index' => 'int',
        'end_shape_index' => 'int',
        'toll' => 'bool',
        'rough' => 'bool',
        'gate' => 'bool',
        'ferry' => 'bool',
        'sign' => '\OpenAPI\Client\Model\ManeuverSign',
        'roundabout_exit_count' => 'int',
        'depart_instruction' => 'int',
        'verbal_depart_instruction' => 'int',
        'arrive_instruction' => 'int',
        'verbal_arrive_instruction' => 'int',
        'transit_info' => 'array<string,mixed>',
        'verbal_multi_cue' => 'bool',
        'travel_mode' => '\OpenAPI\Client\Model\TravelMode',
        'travel_type' => 'string',
        'bss_maneuver_type' => 'string'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'type' => null,
        'instruction' => null,
        'verbal_transition_alert_instruction' => null,
        'verbal_pre_transition_instruction' => null,
        'verbal_post_transition_instruction' => null,
        'street_names' => null,
        'begin_street_names' => null,
        'time' => 'double',
        'length' => 'double',
        'begin_shape_index' => null,
        'end_shape_index' => null,
        'toll' => null,
        'rough' => null,
        'gate' => null,
        'ferry' => null,
        'sign' => null,
        'roundabout_exit_count' => null,
        'depart_instruction' => null,
        'verbal_depart_instruction' => null,
        'arrive_instruction' => null,
        'verbal_arrive_instruction' => null,
        'transit_info' => null,
        'verbal_multi_cue' => null,
        'travel_mode' => null,
        'travel_type' => null,
        'bss_maneuver_type' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'type' => false,
        'instruction' => false,
        'verbal_transition_alert_instruction' => false,
        'verbal_pre_transition_instruction' => false,
        'verbal_post_transition_instruction' => false,
        'street_names' => false,
        'begin_street_names' => false,
        'time' => false,
        'length' => false,
        'begin_shape_index' => false,
        'end_shape_index' => false,
        'toll' => false,
        'rough' => false,
        'gate' => false,
        'ferry' => false,
        'sign' => false,
        'roundabout_exit_count' => false,
        'depart_instruction' => false,
        'verbal_depart_instruction' => false,
        'arrive_instruction' => false,
        'verbal_arrive_instruction' => false,
        'transit_info' => false,
        'verbal_multi_cue' => false,
        'travel_mode' => false,
        'travel_type' => false,
        'bss_maneuver_type' => false
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param boolean[] $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'type' => 'type',
        'instruction' => 'instruction',
        'verbal_transition_alert_instruction' => 'verbal_transition_alert_instruction',
        'verbal_pre_transition_instruction' => 'verbal_pre_transition_instruction',
        'verbal_post_transition_instruction' => 'verbal_post_transition_instruction',
        'street_names' => 'street_names',
        'begin_street_names' => 'begin_street_names',
        'time' => 'time',
        'length' => 'length',
        'begin_shape_index' => 'begin_shape_index',
        'end_shape_index' => 'end_shape_index',
        'toll' => 'toll',
        'rough' => 'rough',
        'gate' => 'gate',
        'ferry' => 'ferry',
        'sign' => 'sign',
        'roundabout_exit_count' => 'roundabout_exit_count',
        'depart_instruction' => 'depart_instruction',
        'verbal_depart_instruction' => 'verbal_depart_instruction',
        'arrive_instruction' => 'arrive_instruction',
        'verbal_arrive_instruction' => 'verbal_arrive_instruction',
        'transit_info' => 'transit_info',
        'verbal_multi_cue' => 'verbal_multi_cue',
        'travel_mode' => 'travel_mode',
        'travel_type' => 'travel_type',
        'bss_maneuver_type' => 'bss_maneuver_type'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'type' => 'setType',
        'instruction' => 'setInstruction',
        'verbal_transition_alert_instruction' => 'setVerbalTransitionAlertInstruction',
        'verbal_pre_transition_instruction' => 'setVerbalPreTransitionInstruction',
        'verbal_post_transition_instruction' => 'setVerbalPostTransitionInstruction',
        'street_names' => 'setStreetNames',
        'begin_street_names' => 'setBeginStreetNames',
        'time' => 'setTime',
        'length' => 'setLength',
        'begin_shape_index' => 'setBeginShapeIndex',
        'end_shape_index' => 'setEndShapeIndex',
        'toll' => 'setToll',
        'rough' => 'setRough',
        'gate' => 'setGate',
        'ferry' => 'setFerry',
        'sign' => 'setSign',
        'roundabout_exit_count' => 'setRoundaboutExitCount',
        'depart_instruction' => 'setDepartInstruction',
        'verbal_depart_instruction' => 'setVerbalDepartInstruction',
        'arrive_instruction' => 'setArriveInstruction',
        'verbal_arrive_instruction' => 'setVerbalArriveInstruction',
        'transit_info' => 'setTransitInfo',
        'verbal_multi_cue' => 'setVerbalMultiCue',
        'travel_mode' => 'setTravelMode',
        'travel_type' => 'setTravelType',
        'bss_maneuver_type' => 'setBssManeuverType'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'type' => 'getType',
        'instruction' => 'getInstruction',
        'verbal_transition_alert_instruction' => 'getVerbalTransitionAlertInstruction',
        'verbal_pre_transition_instruction' => 'getVerbalPreTransitionInstruction',
        'verbal_post_transition_instruction' => 'getVerbalPostTransitionInstruction',
        'street_names' => 'getStreetNames',
        'begin_street_names' => 'getBeginStreetNames',
        'time' => 'getTime',
        'length' => 'getLength',
        'begin_shape_index' => 'getBeginShapeIndex',
        'end_shape_index' => 'getEndShapeIndex',
        'toll' => 'getToll',
        'rough' => 'getRough',
        'gate' => 'getGate',
        'ferry' => 'getFerry',
        'sign' => 'getSign',
        'roundabout_exit_count' => 'getRoundaboutExitCount',
        'depart_instruction' => 'getDepartInstruction',
        'verbal_depart_instruction' => 'getVerbalDepartInstruction',
        'arrive_instruction' => 'getArriveInstruction',
        'verbal_arrive_instruction' => 'getVerbalArriveInstruction',
        'transit_info' => 'getTransitInfo',
        'verbal_multi_cue' => 'getVerbalMultiCue',
        'travel_mode' => 'getTravelMode',
        'travel_type' => 'getTravelType',
        'bss_maneuver_type' => 'getBssManeuverType'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    public const TRAVEL_TYPE_CAR = 'car';
    public const TRAVEL_TYPE_MOTORCYCLE = 'motorcycle';
    public const TRAVEL_TYPE_BUS = 'bus';
    public const TRAVEL_TYPE_TRACTOR_TRAILER = 'tractor_trailer';
    public const TRAVEL_TYPE_MOTOR_SCOOTER = 'motor_scooter';
    public const TRAVEL_TYPE_FOOT = 'foot';
    public const TRAVEL_TYPE_WHEELCHAIR = 'wheelchair';
    public const TRAVEL_TYPE_SEGWAY = 'segway';
    public const TRAVEL_TYPE_ROAD = 'road';
    public const TRAVEL_TYPE_CROSS = 'cross';
    public const TRAVEL_TYPE_HYBRID = 'hybrid';
    public const TRAVEL_TYPE_MOUNTAIN = 'mountain';
    public const TRAVEL_TYPE_TRAM = 'tram';
    public const TRAVEL_TYPE_METRO = 'metro';
    public const TRAVEL_TYPE_RAIL = 'rail';
    public const TRAVEL_TYPE_FERRY = 'ferry';
    public const TRAVEL_TYPE_CABLE_CAR = 'cable_car';
    public const TRAVEL_TYPE_GONDOLA = 'gondola';
    public const TRAVEL_TYPE_FUNICULAR = 'funicular';
    public const TRAVEL_TYPE_GOLF_CART = 'golf_cart';
    public const TRAVEL_TYPE_LOW_SPEED_VEHICLE = 'low_speed_vehicle';
    public const BSS_MANEUVER_TYPE_NONE_ACTION = 'NoneAction';
    public const BSS_MANEUVER_TYPE_RENT_BIKE_AT_BIKE_SHARE = 'RentBikeAtBikeShare';
    public const BSS_MANEUVER_TYPE_RETURN_BIKE_AT_BIKE_SHARE = 'ReturnBikeAtBikeShare';

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getTravelTypeAllowableValues()
    {
        return [
            self::TRAVEL_TYPE_CAR,
            self::TRAVEL_TYPE_MOTORCYCLE,
            self::TRAVEL_TYPE_BUS,
            self::TRAVEL_TYPE_TRACTOR_TRAILER,
            self::TRAVEL_TYPE_MOTOR_SCOOTER,
            self::TRAVEL_TYPE_FOOT,
            self::TRAVEL_TYPE_WHEELCHAIR,
            self::TRAVEL_TYPE_SEGWAY,
            self::TRAVEL_TYPE_ROAD,
            self::TRAVEL_TYPE_CROSS,
            self::TRAVEL_TYPE_HYBRID,
            self::TRAVEL_TYPE_MOUNTAIN,
            self::TRAVEL_TYPE_TRAM,
            self::TRAVEL_TYPE_METRO,
            self::TRAVEL_TYPE_RAIL,
            self::TRAVEL_TYPE_FERRY,
            self::TRAVEL_TYPE_CABLE_CAR,
            self::TRAVEL_TYPE_GONDOLA,
            self::TRAVEL_TYPE_FUNICULAR,
            self::TRAVEL_TYPE_GOLF_CART,
            self::TRAVEL_TYPE_LOW_SPEED_VEHICLE,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getBssManeuverTypeAllowableValues()
    {
        return [
            self::BSS_MANEUVER_TYPE_NONE_ACTION,
            self::BSS_MANEUVER_TYPE_RENT_BIKE_AT_BIKE_SHARE,
            self::BSS_MANEUVER_TYPE_RETURN_BIKE_AT_BIKE_SHARE,
        ];
    }

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->setIfExists('type', $data ?? [], null);
        $this->setIfExists('instruction', $data ?? [], null);
        $this->setIfExists('verbal_transition_alert_instruction', $data ?? [], null);
        $this->setIfExists('verbal_pre_transition_instruction', $data ?? [], null);
        $this->setIfExists('verbal_post_transition_instruction', $data ?? [], null);
        $this->setIfExists('street_names', $data ?? [], null);
        $this->setIfExists('begin_street_names', $data ?? [], null);
        $this->setIfExists('time', $data ?? [], null);
        $this->setIfExists('length', $data ?? [], null);
        $this->setIfExists('begin_shape_index', $data ?? [], null);
        $this->setIfExists('end_shape_index', $data ?? [], null);
        $this->setIfExists('toll', $data ?? [], false);
        $this->setIfExists('rough', $data ?? [], false);
        $this->setIfExists('gate', $data ?? [], false);
        $this->setIfExists('ferry', $data ?? [], false);
        $this->setIfExists('sign', $data ?? [], null);
        $this->setIfExists('roundabout_exit_count', $data ?? [], null);
        $this->setIfExists('depart_instruction', $data ?? [], null);
        $this->setIfExists('verbal_depart_instruction', $data ?? [], null);
        $this->setIfExists('arrive_instruction', $data ?? [], null);
        $this->setIfExists('verbal_arrive_instruction', $data ?? [], null);
        $this->setIfExists('transit_info', $data ?? [], null);
        $this->setIfExists('verbal_multi_cue', $data ?? [], false);
        $this->setIfExists('travel_mode', $data ?? [], null);
        $this->setIfExists('travel_type', $data ?? [], null);
        $this->setIfExists('bss_maneuver_type', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if ($this->container['type'] === null) {
            $invalidProperties[] = "'type' can't be null";
        }
        if ($this->container['instruction'] === null) {
            $invalidProperties[] = "'instruction' can't be null";
        }
        if ($this->container['time'] === null) {
            $invalidProperties[] = "'time' can't be null";
        }
        if ($this->container['length'] === null) {
            $invalidProperties[] = "'length' can't be null";
        }
        if ($this->container['begin_shape_index'] === null) {
            $invalidProperties[] = "'begin_shape_index' can't be null";
        }
        if ($this->container['end_shape_index'] === null) {
            $invalidProperties[] = "'end_shape_index' can't be null";
        }
        if ($this->container['travel_mode'] === null) {
            $invalidProperties[] = "'travel_mode' can't be null";
        }
        if ($this->container['travel_type'] === null) {
            $invalidProperties[] = "'travel_type' can't be null";
        }
        $allowedValues = $this->getTravelTypeAllowableValues();
        if (!is_null($this->container['travel_type']) && !in_array($this->container['travel_type'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'travel_type', must be one of '%s'",
                $this->container['travel_type'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getBssManeuverTypeAllowableValues();
        if (!is_null($this->container['bss_maneuver_type']) && !in_array($this->container['bss_maneuver_type'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'bss_maneuver_type', must be one of '%s'",
                $this->container['bss_maneuver_type'],
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets type
     *
     * @return int
     */
    public function getType()
    {
        return $this->container['type'];
    }

    /**
     * Sets type
     *
     * @param int $type The type of route maneuver.  | Code | Type                                | |------|-------------------------------------| | 0    | None                                | | 1    | Start                               | | 2    | Start right                         | | 3    | Start left                          | | 4    | Destination                         | | 5    | Destination right                   | | 6    | Destination left                    | | 7    | Becomes                             | | 8    | Continue                            | | 9    | Slight right                        | | 10   | Right                               | | 11   | Sharp right                         | | 12   | U-turn right                        | | 13   | U-turn left                         | | 14   | Sharp left                          | | 15   | Left                                | | 16   | Slight left                         | | 17   | Ramp straight                       | | 18   | Ramp right                          | | 19   | Ramp left                           | | 20   | Exit right                          | | 21   | Exit left                           | | 22   | Stay straight                       | | 23   | Stay right                          | | 24   | Stay left                           | | 25   | Merge                               | | 26   | Enter roundabout                    | | 27   | Exit roundabout                     | | 28   | Enter ferry                         | | 29   | Exit ferry                          | | 30   | Transit                             | | 31   | Transit transfer                    | | 32   | Transit remain on                   | | 33   | Transit connection start            | | 34   | Transit connection transfer         | | 35   | Transit connection destination      | | 36   | Post-transit connection destination | | 37   | Merge right                         | | 38   | Merge left                          |
     *
     * @return self
     */
    public function setType($type)
    {
        if (is_null($type)) {
            throw new \InvalidArgumentException('non-nullable type cannot be null');
        }
        $this->container['type'] = $type;

        return $this;
    }

    /**
     * Gets instruction
     *
     * @return string
     */
    public function getInstruction()
    {
        return $this->container['instruction'];
    }

    /**
     * Sets instruction
     *
     * @param string $instruction The written maneuver instruction.
     *
     * @return self
     */
    public function setInstruction($instruction)
    {
        if (is_null($instruction)) {
            throw new \InvalidArgumentException('non-nullable instruction cannot be null');
        }
        $this->container['instruction'] = $instruction;

        return $this;
    }

    /**
     * Gets verbal_transition_alert_instruction
     *
     * @return string|null
     */
    public function getVerbalTransitionAlertInstruction()
    {
        return $this->container['verbal_transition_alert_instruction'];
    }

    /**
     * Sets verbal_transition_alert_instruction
     *
     * @param string|null $verbal_transition_alert_instruction Text suitable for use as a verbal navigation alert.
     *
     * @return self
     */
    public function setVerbalTransitionAlertInstruction($verbal_transition_alert_instruction)
    {
        if (is_null($verbal_transition_alert_instruction)) {
            throw new \InvalidArgumentException('non-nullable verbal_transition_alert_instruction cannot be null');
        }
        $this->container['verbal_transition_alert_instruction'] = $verbal_transition_alert_instruction;

        return $this;
    }

    /**
     * Gets verbal_pre_transition_instruction
     *
     * @return string|null
     */
    public function getVerbalPreTransitionInstruction()
    {
        return $this->container['verbal_pre_transition_instruction'];
    }

    /**
     * Sets verbal_pre_transition_instruction
     *
     * @param string|null $verbal_pre_transition_instruction Text suitable for use as a verbal navigation alert immediately prior to the maneuver transition.
     *
     * @return self
     */
    public function setVerbalPreTransitionInstruction($verbal_pre_transition_instruction)
    {
        if (is_null($verbal_pre_transition_instruction)) {
            throw new \InvalidArgumentException('non-nullable verbal_pre_transition_instruction cannot be null');
        }
        $this->container['verbal_pre_transition_instruction'] = $verbal_pre_transition_instruction;

        return $this;
    }

    /**
     * Gets verbal_post_transition_instruction
     *
     * @return string|null
     */
    public function getVerbalPostTransitionInstruction()
    {
        return $this->container['verbal_post_transition_instruction'];
    }

    /**
     * Sets verbal_post_transition_instruction
     *
     * @param string|null $verbal_post_transition_instruction Text suitable for use as a verbal navigation alert immediately after to the maneuver transition.
     *
     * @return self
     */
    public function setVerbalPostTransitionInstruction($verbal_post_transition_instruction)
    {
        if (is_null($verbal_post_transition_instruction)) {
            throw new \InvalidArgumentException('non-nullable verbal_post_transition_instruction cannot be null');
        }
        $this->container['verbal_post_transition_instruction'] = $verbal_post_transition_instruction;

        return $this;
    }

    /**
     * Gets street_names
     *
     * @return string[]|null
     */
    public function getStreetNames()
    {
        return $this->container['street_names'];
    }

    /**
     * Sets street_names
     *
     * @param string[]|null $street_names A list of street names that are consistent along the entire maneuver.
     *
     * @return self
     */
    public function setStreetNames($street_names)
    {
        if (is_null($street_names)) {
            throw new \InvalidArgumentException('non-nullable street_names cannot be null');
        }
        $this->container['street_names'] = $street_names;

        return $this;
    }

    /**
     * Gets begin_street_names
     *
     * @return string[]|null
     */
    public function getBeginStreetNames()
    {
        return $this->container['begin_street_names'];
    }

    /**
     * Sets begin_street_names
     *
     * @param string[]|null $begin_street_names A list of street names at the beginning of the maneuver, if they are different from the names at the end.
     *
     * @return self
     */
    public function setBeginStreetNames($begin_street_names)
    {
        if (is_null($begin_street_names)) {
            throw new \InvalidArgumentException('non-nullable begin_street_names cannot be null');
        }
        $this->container['begin_street_names'] = $begin_street_names;

        return $this;
    }

    /**
     * Gets time
     *
     * @return float
     */
    public function getTime()
    {
        return $this->container['time'];
    }

    /**
     * Sets time
     *
     * @param float $time The estimated time to complete the entire maneuver, in seconds.
     *
     * @return self
     */
    public function setTime($time)
    {
        if (is_null($time)) {
            throw new \InvalidArgumentException('non-nullable time cannot be null');
        }
        $this->container['time'] = $time;

        return $this;
    }

    /**
     * Gets length
     *
     * @return float
     */
    public function getLength()
    {
        return $this->container['length'];
    }

    /**
     * Sets length
     *
     * @param float $length The length of the maneuver, in `units`.
     *
     * @return self
     */
    public function setLength($length)
    {
        if (is_null($length)) {
            throw new \InvalidArgumentException('non-nullable length cannot be null');
        }
        $this->container['length'] = $length;

        return $this;
    }

    /**
     * Gets begin_shape_index
     *
     * @return int
     */
    public function getBeginShapeIndex()
    {
        return $this->container['begin_shape_index'];
    }

    /**
     * Sets begin_shape_index
     *
     * @param int $begin_shape_index The index into the list of shape points for the start of the maneuver.
     *
     * @return self
     */
    public function setBeginShapeIndex($begin_shape_index)
    {
        if (is_null($begin_shape_index)) {
            throw new \InvalidArgumentException('non-nullable begin_shape_index cannot be null');
        }
        $this->container['begin_shape_index'] = $begin_shape_index;

        return $this;
    }

    /**
     * Gets end_shape_index
     *
     * @return int
     */
    public function getEndShapeIndex()
    {
        return $this->container['end_shape_index'];
    }

    /**
     * Sets end_shape_index
     *
     * @param int $end_shape_index The index into the list of shape points for the end of the maneuver.
     *
     * @return self
     */
    public function setEndShapeIndex($end_shape_index)
    {
        if (is_null($end_shape_index)) {
            throw new \InvalidArgumentException('non-nullable end_shape_index cannot be null');
        }
        $this->container['end_shape_index'] = $end_shape_index;

        return $this;
    }

    /**
     * Gets toll
     *
     * @return bool|null
     */
    public function getToll()
    {
        return $this->container['toll'];
    }

    /**
     * Sets toll
     *
     * @param bool|null $toll True any portion of the maneuver is subject to a toll.
     *
     * @return self
     */
    public function setToll($toll)
    {
        if (is_null($toll)) {
            throw new \InvalidArgumentException('non-nullable toll cannot be null');
        }
        $this->container['toll'] = $toll;

        return $this;
    }

    /**
     * Gets rough
     *
     * @return bool|null
     */
    public function getRough()
    {
        return $this->container['rough'];
    }

    /**
     * Sets rough
     *
     * @param bool|null $rough True any portion of the maneuver is unpaved or has portions of rough pavement.
     *
     * @return self
     */
    public function setRough($rough)
    {
        if (is_null($rough)) {
            throw new \InvalidArgumentException('non-nullable rough cannot be null');
        }
        $this->container['rough'] = $rough;

        return $this;
    }

    /**
     * Gets gate
     *
     * @return bool|null
     */
    public function getGate()
    {
        return $this->container['gate'];
    }

    /**
     * Sets gate
     *
     * @param bool|null $gate True if a gate is encountered in the course of this maneuver.
     *
     * @return self
     */
    public function setGate($gate)
    {
        if (is_null($gate)) {
            throw new \InvalidArgumentException('non-nullable gate cannot be null');
        }
        $this->container['gate'] = $gate;

        return $this;
    }

    /**
     * Gets ferry
     *
     * @return bool|null
     */
    public function getFerry()
    {
        return $this->container['ferry'];
    }

    /**
     * Sets ferry
     *
     * @param bool|null $ferry True if a ferry is encountered in the course of this maneuver.
     *
     * @return self
     */
    public function setFerry($ferry)
    {
        if (is_null($ferry)) {
            throw new \InvalidArgumentException('non-nullable ferry cannot be null');
        }
        $this->container['ferry'] = $ferry;

        return $this;
    }

    /**
     * Gets sign
     *
     * @return \OpenAPI\Client\Model\ManeuverSign|null
     */
    public function getSign()
    {
        return $this->container['sign'];
    }

    /**
     * Sets sign
     *
     * @param \OpenAPI\Client\Model\ManeuverSign|null $sign sign
     *
     * @return self
     */
    public function setSign($sign)
    {
        if (is_null($sign)) {
            throw new \InvalidArgumentException('non-nullable sign cannot be null');
        }
        $this->container['sign'] = $sign;

        return $this;
    }

    /**
     * Gets roundabout_exit_count
     *
     * @return int|null
     */
    public function getRoundaboutExitCount()
    {
        return $this->container['roundabout_exit_count'];
    }

    /**
     * Sets roundabout_exit_count
     *
     * @param int|null $roundabout_exit_count The exit number of the roundabout to take after entering.
     *
     * @return self
     */
    public function setRoundaboutExitCount($roundabout_exit_count)
    {
        if (is_null($roundabout_exit_count)) {
            throw new \InvalidArgumentException('non-nullable roundabout_exit_count cannot be null');
        }
        $this->container['roundabout_exit_count'] = $roundabout_exit_count;

        return $this;
    }

    /**
     * Gets depart_instruction
     *
     * @return int|null
     */
    public function getDepartInstruction()
    {
        return $this->container['depart_instruction'];
    }

    /**
     * Sets depart_instruction
     *
     * @param int|null $depart_instruction The written departure time instruction (typically used in a transit maneuver).
     *
     * @return self
     */
    public function setDepartInstruction($depart_instruction)
    {
        if (is_null($depart_instruction)) {
            throw new \InvalidArgumentException('non-nullable depart_instruction cannot be null');
        }
        $this->container['depart_instruction'] = $depart_instruction;

        return $this;
    }

    /**
     * Gets verbal_depart_instruction
     *
     * @return int|null
     */
    public function getVerbalDepartInstruction()
    {
        return $this->container['verbal_depart_instruction'];
    }

    /**
     * Sets verbal_depart_instruction
     *
     * @param int|null $verbal_depart_instruction Text suitable for use as a verbal departure time instruction (typically used in a transit maneuver).
     *
     * @return self
     */
    public function setVerbalDepartInstruction($verbal_depart_instruction)
    {
        if (is_null($verbal_depart_instruction)) {
            throw new \InvalidArgumentException('non-nullable verbal_depart_instruction cannot be null');
        }
        $this->container['verbal_depart_instruction'] = $verbal_depart_instruction;

        return $this;
    }

    /**
     * Gets arrive_instruction
     *
     * @return int|null
     */
    public function getArriveInstruction()
    {
        return $this->container['arrive_instruction'];
    }

    /**
     * Sets arrive_instruction
     *
     * @param int|null $arrive_instruction The written arrival time instruction (typically used in a transit maneuver).
     *
     * @return self
     */
    public function setArriveInstruction($arrive_instruction)
    {
        if (is_null($arrive_instruction)) {
            throw new \InvalidArgumentException('non-nullable arrive_instruction cannot be null');
        }
        $this->container['arrive_instruction'] = $arrive_instruction;

        return $this;
    }

    /**
     * Gets verbal_arrive_instruction
     *
     * @return int|null
     */
    public function getVerbalArriveInstruction()
    {
        return $this->container['verbal_arrive_instruction'];
    }

    /**
     * Sets verbal_arrive_instruction
     *
     * @param int|null $verbal_arrive_instruction Text suitable for use as a verbal departure time instruction (typically used in a transit maneuver).
     *
     * @return self
     */
    public function setVerbalArriveInstruction($verbal_arrive_instruction)
    {
        if (is_null($verbal_arrive_instruction)) {
            throw new \InvalidArgumentException('non-nullable verbal_arrive_instruction cannot be null');
        }
        $this->container['verbal_arrive_instruction'] = $verbal_arrive_instruction;

        return $this;
    }

    /**
     * Gets transit_info
     *
     * @return array<string,mixed>|null
     */
    public function getTransitInfo()
    {
        return $this->container['transit_info'];
    }

    /**
     * Sets transit_info
     *
     * @param array<string,mixed>|null $transit_info Public transit info (not currently supported).
     *
     * @return self
     */
    public function setTransitInfo($transit_info)
    {
        if (is_null($transit_info)) {
            throw new \InvalidArgumentException('non-nullable transit_info cannot be null');
        }
        $this->container['transit_info'] = $transit_info;

        return $this;
    }

    /**
     * Gets verbal_multi_cue
     *
     * @return bool|null
     */
    public function getVerbalMultiCue()
    {
        return $this->container['verbal_multi_cue'];
    }

    /**
     * Sets verbal_multi_cue
     *
     * @param bool|null $verbal_multi_cue True if the `verbal_pre_transition_instruction` has been appended with the verbal instruction of the next maneuver.
     *
     * @return self
     */
    public function setVerbalMultiCue($verbal_multi_cue)
    {
        if (is_null($verbal_multi_cue)) {
            throw new \InvalidArgumentException('non-nullable verbal_multi_cue cannot be null');
        }
        $this->container['verbal_multi_cue'] = $verbal_multi_cue;

        return $this;
    }

    /**
     * Gets travel_mode
     *
     * @return \OpenAPI\Client\Model\TravelMode
     */
    public function getTravelMode()
    {
        return $this->container['travel_mode'];
    }

    /**
     * Sets travel_mode
     *
     * @param \OpenAPI\Client\Model\TravelMode $travel_mode travel_mode
     *
     * @return self
     */
    public function setTravelMode($travel_mode)
    {
        if (is_null($travel_mode)) {
            throw new \InvalidArgumentException('non-nullable travel_mode cannot be null');
        }
        $this->container['travel_mode'] = $travel_mode;

        return $this;
    }

    /**
     * Gets travel_type
     *
     * @return string
     */
    public function getTravelType()
    {
        return $this->container['travel_type'];
    }

    /**
     * Sets travel_type
     *
     * @param string $travel_type The type of travel over the maneuver. This can be thought of as a specialization of the travel mode. For example, vehicular travel may be via car, motorcycle, etc.; and travel via bicycle may be via a road bike, mountain bike, etc.
     *
     * @return self
     */
    public function setTravelType($travel_type)
    {
        if (is_null($travel_type)) {
            throw new \InvalidArgumentException('non-nullable travel_type cannot be null');
        }
        $allowedValues = $this->getTravelTypeAllowableValues();
        if (!in_array($travel_type, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'travel_type', must be one of '%s'",
                    $travel_type,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['travel_type'] = $travel_type;

        return $this;
    }

    /**
     * Gets bss_maneuver_type
     *
     * @return string|null
     */
    public function getBssManeuverType()
    {
        return $this->container['bss_maneuver_type'];
    }

    /**
     * Sets bss_maneuver_type
     *
     * @param string|null $bss_maneuver_type Describes a bike share action when using bikeshare routing.
     *
     * @return self
     */
    public function setBssManeuverType($bss_maneuver_type)
    {
        if (is_null($bss_maneuver_type)) {
            throw new \InvalidArgumentException('non-nullable bss_maneuver_type cannot be null');
        }
        $allowedValues = $this->getBssManeuverTypeAllowableValues();
        if (!in_array($bss_maneuver_type, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'bss_maneuver_type', must be one of '%s'",
                    $bss_maneuver_type,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['bss_maneuver_type'] = $bss_maneuver_type;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


