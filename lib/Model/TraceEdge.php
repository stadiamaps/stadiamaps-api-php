<?php
/**
 * TraceEdge
 *
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Stadia Maps Geospatial APIs
 *
 * The Stadia Maps Geospatial APIs provide you with the data you need to build awesome applications.
 *
 * The version of the OpenAPI document: 7.0.0
 * Contact: support@stadiamaps.com
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.8.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Model;

use \ArrayAccess;
use \OpenAPI\Client\ObjectSerializer;

/**
 * TraceEdge Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class TraceEdge implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'traceEdge';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'names' => 'string[]',
        'length' => 'float',
        'speed' => 'int',
        'road_class' => '\OpenAPI\Client\Model\RoadClass',
        'begin_heading' => 'int',
        'end_heading' => 'int',
        'begin_shape_index' => 'int',
        'end_shape_index' => 'int',
        'traversability' => '\OpenAPI\Client\Model\Traversability',
        'use' => '\OpenAPI\Client\Model\EdgeUse',
        'toll' => 'bool',
        'unpaved' => 'bool',
        'tunnel' => 'bool',
        'bridge' => 'bool',
        'roundabout' => 'bool',
        'internal_intersection' => 'bool',
        'drive_on_right' => 'bool',
        'surface' => 'string',
        'sign' => '\OpenAPI\Client\Model\EdgeSign',
        'travel_mode' => '\OpenAPI\Client\Model\TravelMode',
        'vehicle_type' => 'string',
        'pedestrian_type' => 'string',
        'bicycle_type' => 'string',
        'transit_type' => 'string',
        'id' => 'int',
        'way_id' => 'int',
        'weighted_grade' => 'float',
        'max_upward_grade' => 'int',
        'max_downward_grade' => 'int',
        'mean_elevation' => 'int',
        'lane_count' => 'int',
        'cycle_lane' => 'string',
        'bicycle_network' => 'int',
        'sac_scale' => 'int',
        'sidewalk' => 'string',
        'density' => 'int',
        'speed_limit' => 'mixed',
        'truck_speed' => 'int',
        'truck_route' => 'bool',
        'end_node' => '\OpenAPI\Client\Model\EndNode'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'names' => null,
        'length' => 'double',
        'speed' => null,
        'road_class' => null,
        'begin_heading' => null,
        'end_heading' => null,
        'begin_shape_index' => null,
        'end_shape_index' => null,
        'traversability' => null,
        'use' => null,
        'toll' => null,
        'unpaved' => null,
        'tunnel' => null,
        'bridge' => null,
        'roundabout' => null,
        'internal_intersection' => null,
        'drive_on_right' => null,
        'surface' => null,
        'sign' => null,
        'travel_mode' => null,
        'vehicle_type' => null,
        'pedestrian_type' => null,
        'bicycle_type' => null,
        'transit_type' => null,
        'id' => 'int64',
        'way_id' => 'int64',
        'weighted_grade' => 'double',
        'max_upward_grade' => null,
        'max_downward_grade' => null,
        'mean_elevation' => null,
        'lane_count' => null,
        'cycle_lane' => null,
        'bicycle_network' => null,
        'sac_scale' => null,
        'sidewalk' => null,
        'density' => null,
        'speed_limit' => null,
        'truck_speed' => null,
        'truck_route' => null,
        'end_node' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'names' => false,
        'length' => false,
        'speed' => false,
        'road_class' => false,
        'begin_heading' => false,
        'end_heading' => false,
        'begin_shape_index' => false,
        'end_shape_index' => false,
        'traversability' => false,
        'use' => false,
        'toll' => false,
        'unpaved' => false,
        'tunnel' => false,
        'bridge' => false,
        'roundabout' => false,
        'internal_intersection' => false,
        'drive_on_right' => false,
        'surface' => false,
        'sign' => false,
        'travel_mode' => false,
        'vehicle_type' => false,
        'pedestrian_type' => false,
        'bicycle_type' => false,
        'transit_type' => false,
        'id' => false,
        'way_id' => false,
        'weighted_grade' => false,
        'max_upward_grade' => false,
        'max_downward_grade' => false,
        'mean_elevation' => false,
        'lane_count' => false,
        'cycle_lane' => false,
        'bicycle_network' => false,
        'sac_scale' => false,
        'sidewalk' => false,
        'density' => false,
        'speed_limit' => true,
        'truck_speed' => false,
        'truck_route' => false,
        'end_node' => false
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param boolean[] $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'names' => 'names',
        'length' => 'length',
        'speed' => 'speed',
        'road_class' => 'road_class',
        'begin_heading' => 'begin_heading',
        'end_heading' => 'end_heading',
        'begin_shape_index' => 'begin_shape_index',
        'end_shape_index' => 'end_shape_index',
        'traversability' => 'traversability',
        'use' => 'use',
        'toll' => 'toll',
        'unpaved' => 'unpaved',
        'tunnel' => 'tunnel',
        'bridge' => 'bridge',
        'roundabout' => 'roundabout',
        'internal_intersection' => 'internal_intersection',
        'drive_on_right' => 'drive_on_right',
        'surface' => 'surface',
        'sign' => 'sign',
        'travel_mode' => 'travel_mode',
        'vehicle_type' => 'vehicle_type',
        'pedestrian_type' => 'pedestrian_type',
        'bicycle_type' => 'bicycle_type',
        'transit_type' => 'transit_type',
        'id' => 'id',
        'way_id' => 'way_id',
        'weighted_grade' => 'weighted_grade',
        'max_upward_grade' => 'max_upward_grade',
        'max_downward_grade' => 'max_downward_grade',
        'mean_elevation' => 'mean_elevation',
        'lane_count' => 'lane_count',
        'cycle_lane' => 'cycle_lane',
        'bicycle_network' => 'bicycle_network',
        'sac_scale' => 'sac_scale',
        'sidewalk' => 'sidewalk',
        'density' => 'density',
        'speed_limit' => 'speed_limit',
        'truck_speed' => 'truck_speed',
        'truck_route' => 'truck_route',
        'end_node' => 'end_node'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'names' => 'setNames',
        'length' => 'setLength',
        'speed' => 'setSpeed',
        'road_class' => 'setRoadClass',
        'begin_heading' => 'setBeginHeading',
        'end_heading' => 'setEndHeading',
        'begin_shape_index' => 'setBeginShapeIndex',
        'end_shape_index' => 'setEndShapeIndex',
        'traversability' => 'setTraversability',
        'use' => 'setUse',
        'toll' => 'setToll',
        'unpaved' => 'setUnpaved',
        'tunnel' => 'setTunnel',
        'bridge' => 'setBridge',
        'roundabout' => 'setRoundabout',
        'internal_intersection' => 'setInternalIntersection',
        'drive_on_right' => 'setDriveOnRight',
        'surface' => 'setSurface',
        'sign' => 'setSign',
        'travel_mode' => 'setTravelMode',
        'vehicle_type' => 'setVehicleType',
        'pedestrian_type' => 'setPedestrianType',
        'bicycle_type' => 'setBicycleType',
        'transit_type' => 'setTransitType',
        'id' => 'setId',
        'way_id' => 'setWayId',
        'weighted_grade' => 'setWeightedGrade',
        'max_upward_grade' => 'setMaxUpwardGrade',
        'max_downward_grade' => 'setMaxDownwardGrade',
        'mean_elevation' => 'setMeanElevation',
        'lane_count' => 'setLaneCount',
        'cycle_lane' => 'setCycleLane',
        'bicycle_network' => 'setBicycleNetwork',
        'sac_scale' => 'setSacScale',
        'sidewalk' => 'setSidewalk',
        'density' => 'setDensity',
        'speed_limit' => 'setSpeedLimit',
        'truck_speed' => 'setTruckSpeed',
        'truck_route' => 'setTruckRoute',
        'end_node' => 'setEndNode'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'names' => 'getNames',
        'length' => 'getLength',
        'speed' => 'getSpeed',
        'road_class' => 'getRoadClass',
        'begin_heading' => 'getBeginHeading',
        'end_heading' => 'getEndHeading',
        'begin_shape_index' => 'getBeginShapeIndex',
        'end_shape_index' => 'getEndShapeIndex',
        'traversability' => 'getTraversability',
        'use' => 'getUse',
        'toll' => 'getToll',
        'unpaved' => 'getUnpaved',
        'tunnel' => 'getTunnel',
        'bridge' => 'getBridge',
        'roundabout' => 'getRoundabout',
        'internal_intersection' => 'getInternalIntersection',
        'drive_on_right' => 'getDriveOnRight',
        'surface' => 'getSurface',
        'sign' => 'getSign',
        'travel_mode' => 'getTravelMode',
        'vehicle_type' => 'getVehicleType',
        'pedestrian_type' => 'getPedestrianType',
        'bicycle_type' => 'getBicycleType',
        'transit_type' => 'getTransitType',
        'id' => 'getId',
        'way_id' => 'getWayId',
        'weighted_grade' => 'getWeightedGrade',
        'max_upward_grade' => 'getMaxUpwardGrade',
        'max_downward_grade' => 'getMaxDownwardGrade',
        'mean_elevation' => 'getMeanElevation',
        'lane_count' => 'getLaneCount',
        'cycle_lane' => 'getCycleLane',
        'bicycle_network' => 'getBicycleNetwork',
        'sac_scale' => 'getSacScale',
        'sidewalk' => 'getSidewalk',
        'density' => 'getDensity',
        'speed_limit' => 'getSpeedLimit',
        'truck_speed' => 'getTruckSpeed',
        'truck_route' => 'getTruckRoute',
        'end_node' => 'getEndNode'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    public const SURFACE_PAVED_SMOOTH = 'paved_smooth';
    public const SURFACE_PAVED = 'paved';
    public const SURFACE_PAVED_ROUGH = 'paved_rough';
    public const SURFACE_COMPACTED = 'compacted';
    public const SURFACE_DIRT = 'dirt';
    public const SURFACE_GRAVEL = 'gravel';
    public const SURFACE_PATH = 'path';
    public const SURFACE_IMPASSABLE = 'impassable';
    public const VEHICLE_TYPE_CAR = 'car';
    public const VEHICLE_TYPE_MOTORCYCLE = 'motorcycle';
    public const VEHICLE_TYPE_BUS = 'bus';
    public const VEHICLE_TYPE_TRACTOR_TRAILER = 'tractor_trailer';
    public const VEHICLE_TYPE_GOLF_CART = 'golf_cart';
    public const VEHICLE_TYPE_LOW_SPEED_VEHICLE = 'low_speed_vehicle';
    public const PEDESTRIAN_TYPE_FOOT = 'foot';
    public const PEDESTRIAN_TYPE_WHEELCHAIR = 'wheelchair';
    public const PEDESTRIAN_TYPE_SEGWAY = 'segway';
    public const BICYCLE_TYPE_ROAD = 'road';
    public const BICYCLE_TYPE_CROSS = 'cross';
    public const BICYCLE_TYPE_HYBRID = 'hybrid';
    public const BICYCLE_TYPE_MOUNTAIN = 'mountain';
    public const TRANSIT_TYPE_TRAM = 'tram';
    public const TRANSIT_TYPE_METRO = 'metro';
    public const TRANSIT_TYPE_RAIL = 'rail';
    public const TRANSIT_TYPE_BUS = 'bus';
    public const TRANSIT_TYPE_FERRY = 'ferry';
    public const TRANSIT_TYPE_CABLE_CAR = 'cable_car';
    public const TRANSIT_TYPE_GONDOLA = 'gondola';
    public const TRANSIT_TYPE_FUNICULAR = 'funicular';
    public const CYCLE_LANE_NONE = 'none';
    public const CYCLE_LANE_SHARED = 'shared';
    public const CYCLE_LANE_DEDICATED = 'dedicated';
    public const CYCLE_LANE_SEPARATED = 'separated';
    public const SIDEWALK_LEFT = 'left';
    public const SIDEWALK_RIGHT = 'right';
    public const SIDEWALK_BOTH = 'both';
    public const SIDEWALK_NONE = 'none';

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getSurfaceAllowableValues()
    {
        return [
            self::SURFACE_PAVED_SMOOTH,
            self::SURFACE_PAVED,
            self::SURFACE_PAVED_ROUGH,
            self::SURFACE_COMPACTED,
            self::SURFACE_DIRT,
            self::SURFACE_GRAVEL,
            self::SURFACE_PATH,
            self::SURFACE_IMPASSABLE,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getVehicleTypeAllowableValues()
    {
        return [
            self::VEHICLE_TYPE_CAR,
            self::VEHICLE_TYPE_MOTORCYCLE,
            self::VEHICLE_TYPE_BUS,
            self::VEHICLE_TYPE_TRACTOR_TRAILER,
            self::VEHICLE_TYPE_GOLF_CART,
            self::VEHICLE_TYPE_LOW_SPEED_VEHICLE,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getPedestrianTypeAllowableValues()
    {
        return [
            self::PEDESTRIAN_TYPE_FOOT,
            self::PEDESTRIAN_TYPE_WHEELCHAIR,
            self::PEDESTRIAN_TYPE_SEGWAY,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getBicycleTypeAllowableValues()
    {
        return [
            self::BICYCLE_TYPE_ROAD,
            self::BICYCLE_TYPE_CROSS,
            self::BICYCLE_TYPE_HYBRID,
            self::BICYCLE_TYPE_MOUNTAIN,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getTransitTypeAllowableValues()
    {
        return [
            self::TRANSIT_TYPE_TRAM,
            self::TRANSIT_TYPE_METRO,
            self::TRANSIT_TYPE_RAIL,
            self::TRANSIT_TYPE_BUS,
            self::TRANSIT_TYPE_FERRY,
            self::TRANSIT_TYPE_CABLE_CAR,
            self::TRANSIT_TYPE_GONDOLA,
            self::TRANSIT_TYPE_FUNICULAR,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getCycleLaneAllowableValues()
    {
        return [
            self::CYCLE_LANE_NONE,
            self::CYCLE_LANE_SHARED,
            self::CYCLE_LANE_DEDICATED,
            self::CYCLE_LANE_SEPARATED,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getSidewalkAllowableValues()
    {
        return [
            self::SIDEWALK_LEFT,
            self::SIDEWALK_RIGHT,
            self::SIDEWALK_BOTH,
            self::SIDEWALK_NONE,
        ];
    }

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->setIfExists('names', $data ?? [], null);
        $this->setIfExists('length', $data ?? [], null);
        $this->setIfExists('speed', $data ?? [], null);
        $this->setIfExists('road_class', $data ?? [], null);
        $this->setIfExists('begin_heading', $data ?? [], null);
        $this->setIfExists('end_heading', $data ?? [], null);
        $this->setIfExists('begin_shape_index', $data ?? [], null);
        $this->setIfExists('end_shape_index', $data ?? [], null);
        $this->setIfExists('traversability', $data ?? [], null);
        $this->setIfExists('use', $data ?? [], null);
        $this->setIfExists('toll', $data ?? [], null);
        $this->setIfExists('unpaved', $data ?? [], null);
        $this->setIfExists('tunnel', $data ?? [], null);
        $this->setIfExists('bridge', $data ?? [], null);
        $this->setIfExists('roundabout', $data ?? [], null);
        $this->setIfExists('internal_intersection', $data ?? [], null);
        $this->setIfExists('drive_on_right', $data ?? [], null);
        $this->setIfExists('surface', $data ?? [], null);
        $this->setIfExists('sign', $data ?? [], null);
        $this->setIfExists('travel_mode', $data ?? [], null);
        $this->setIfExists('vehicle_type', $data ?? [], null);
        $this->setIfExists('pedestrian_type', $data ?? [], null);
        $this->setIfExists('bicycle_type', $data ?? [], null);
        $this->setIfExists('transit_type', $data ?? [], null);
        $this->setIfExists('id', $data ?? [], null);
        $this->setIfExists('way_id', $data ?? [], null);
        $this->setIfExists('weighted_grade', $data ?? [], null);
        $this->setIfExists('max_upward_grade', $data ?? [], null);
        $this->setIfExists('max_downward_grade', $data ?? [], null);
        $this->setIfExists('mean_elevation', $data ?? [], null);
        $this->setIfExists('lane_count', $data ?? [], null);
        $this->setIfExists('cycle_lane', $data ?? [], null);
        $this->setIfExists('bicycle_network', $data ?? [], null);
        $this->setIfExists('sac_scale', $data ?? [], null);
        $this->setIfExists('sidewalk', $data ?? [], null);
        $this->setIfExists('density', $data ?? [], null);
        $this->setIfExists('speed_limit', $data ?? [], null);
        $this->setIfExists('truck_speed', $data ?? [], null);
        $this->setIfExists('truck_route', $data ?? [], null);
        $this->setIfExists('end_node', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        $allowedValues = $this->getSurfaceAllowableValues();
        if (!is_null($this->container['surface']) && !in_array($this->container['surface'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'surface', must be one of '%s'",
                $this->container['surface'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getVehicleTypeAllowableValues();
        if (!is_null($this->container['vehicle_type']) && !in_array($this->container['vehicle_type'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'vehicle_type', must be one of '%s'",
                $this->container['vehicle_type'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getPedestrianTypeAllowableValues();
        if (!is_null($this->container['pedestrian_type']) && !in_array($this->container['pedestrian_type'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'pedestrian_type', must be one of '%s'",
                $this->container['pedestrian_type'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getBicycleTypeAllowableValues();
        if (!is_null($this->container['bicycle_type']) && !in_array($this->container['bicycle_type'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'bicycle_type', must be one of '%s'",
                $this->container['bicycle_type'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getTransitTypeAllowableValues();
        if (!is_null($this->container['transit_type']) && !in_array($this->container['transit_type'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'transit_type', must be one of '%s'",
                $this->container['transit_type'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getCycleLaneAllowableValues();
        if (!is_null($this->container['cycle_lane']) && !in_array($this->container['cycle_lane'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'cycle_lane', must be one of '%s'",
                $this->container['cycle_lane'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getSidewalkAllowableValues();
        if (!is_null($this->container['sidewalk']) && !in_array($this->container['sidewalk'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'sidewalk', must be one of '%s'",
                $this->container['sidewalk'],
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets names
     *
     * @return string[]|null
     */
    public function getNames()
    {
        return $this->container['names'];
    }

    /**
     * Sets names
     *
     * @param string[]|null $names The name(s) of the road at this edge, if any.
     *
     * @return self
     */
    public function setNames($names)
    {
        if (is_null($names)) {
            throw new \InvalidArgumentException('non-nullable names cannot be null');
        }
        $this->container['names'] = $names;

        return $this;
    }

    /**
     * Gets length
     *
     * @return float|null
     */
    public function getLength()
    {
        return $this->container['length'];
    }

    /**
     * Sets length
     *
     * @param float|null $length The length of this edge in `units`.
     *
     * @return self
     */
    public function setLength($length)
    {
        if (is_null($length)) {
            throw new \InvalidArgumentException('non-nullable length cannot be null');
        }
        $this->container['length'] = $length;

        return $this;
    }

    /**
     * Gets speed
     *
     * @return int|null
     */
    public function getSpeed()
    {
        return $this->container['speed'];
    }

    /**
     * Sets speed
     *
     * @param int|null $speed The speed of this edge in `units`/hr, in terms of average/free-flow speed for routing purposes. This is affected by any number of factors such as the road service, vehicle type, etc. and not just the posted speed limits.
     *
     * @return self
     */
    public function setSpeed($speed)
    {
        if (is_null($speed)) {
            throw new \InvalidArgumentException('non-nullable speed cannot be null');
        }
        $this->container['speed'] = $speed;

        return $this;
    }

    /**
     * Gets road_class
     *
     * @return \OpenAPI\Client\Model\RoadClass|null
     */
    public function getRoadClass()
    {
        return $this->container['road_class'];
    }

    /**
     * Sets road_class
     *
     * @param \OpenAPI\Client\Model\RoadClass|null $road_class road_class
     *
     * @return self
     */
    public function setRoadClass($road_class)
    {
        if (is_null($road_class)) {
            throw new \InvalidArgumentException('non-nullable road_class cannot be null');
        }
        $this->container['road_class'] = $road_class;

        return $this;
    }

    /**
     * Gets begin_heading
     *
     * @return int|null
     */
    public function getBeginHeading()
    {
        return $this->container['begin_heading'];
    }

    /**
     * Sets begin_heading
     *
     * @param int|null $begin_heading The direction at the beginning of an edge. The units are degrees clockwise from north.
     *
     * @return self
     */
    public function setBeginHeading($begin_heading)
    {
        if (is_null($begin_heading)) {
            throw new \InvalidArgumentException('non-nullable begin_heading cannot be null');
        }
        $this->container['begin_heading'] = $begin_heading;

        return $this;
    }

    /**
     * Gets end_heading
     *
     * @return int|null
     */
    public function getEndHeading()
    {
        return $this->container['end_heading'];
    }

    /**
     * Sets end_heading
     *
     * @param int|null $end_heading The direction at the end of an edge. The units are degrees clockwise from north.
     *
     * @return self
     */
    public function setEndHeading($end_heading)
    {
        if (is_null($end_heading)) {
            throw new \InvalidArgumentException('non-nullable end_heading cannot be null');
        }
        $this->container['end_heading'] = $end_heading;

        return $this;
    }

    /**
     * Gets begin_shape_index
     *
     * @return int|null
     */
    public function getBeginShapeIndex()
    {
        return $this->container['begin_shape_index'];
    }

    /**
     * Sets begin_shape_index
     *
     * @param int|null $begin_shape_index Index into the list of shape points for the start of the edge.
     *
     * @return self
     */
    public function setBeginShapeIndex($begin_shape_index)
    {
        if (is_null($begin_shape_index)) {
            throw new \InvalidArgumentException('non-nullable begin_shape_index cannot be null');
        }
        $this->container['begin_shape_index'] = $begin_shape_index;

        return $this;
    }

    /**
     * Gets end_shape_index
     *
     * @return int|null
     */
    public function getEndShapeIndex()
    {
        return $this->container['end_shape_index'];
    }

    /**
     * Sets end_shape_index
     *
     * @param int|null $end_shape_index Index into the list of shape points for the end of the edge.
     *
     * @return self
     */
    public function setEndShapeIndex($end_shape_index)
    {
        if (is_null($end_shape_index)) {
            throw new \InvalidArgumentException('non-nullable end_shape_index cannot be null');
        }
        $this->container['end_shape_index'] = $end_shape_index;

        return $this;
    }

    /**
     * Gets traversability
     *
     * @return \OpenAPI\Client\Model\Traversability|null
     */
    public function getTraversability()
    {
        return $this->container['traversability'];
    }

    /**
     * Sets traversability
     *
     * @param \OpenAPI\Client\Model\Traversability|null $traversability traversability
     *
     * @return self
     */
    public function setTraversability($traversability)
    {
        if (is_null($traversability)) {
            throw new \InvalidArgumentException('non-nullable traversability cannot be null');
        }
        $this->container['traversability'] = $traversability;

        return $this;
    }

    /**
     * Gets use
     *
     * @return \OpenAPI\Client\Model\EdgeUse|null
     */
    public function getUse()
    {
        return $this->container['use'];
    }

    /**
     * Sets use
     *
     * @param \OpenAPI\Client\Model\EdgeUse|null $use use
     *
     * @return self
     */
    public function setUse($use)
    {
        if (is_null($use)) {
            throw new \InvalidArgumentException('non-nullable use cannot be null');
        }
        $this->container['use'] = $use;

        return $this;
    }

    /**
     * Gets toll
     *
     * @return bool|null
     */
    public function getToll()
    {
        return $this->container['toll'];
    }

    /**
     * Sets toll
     *
     * @param bool|null $toll True if the edge has a toll.
     *
     * @return self
     */
    public function setToll($toll)
    {
        if (is_null($toll)) {
            throw new \InvalidArgumentException('non-nullable toll cannot be null');
        }
        $this->container['toll'] = $toll;

        return $this;
    }

    /**
     * Gets unpaved
     *
     * @return bool|null
     */
    public function getUnpaved()
    {
        return $this->container['unpaved'];
    }

    /**
     * Sets unpaved
     *
     * @param bool|null $unpaved True if the edge has rough payment.
     *
     * @return self
     */
    public function setUnpaved($unpaved)
    {
        if (is_null($unpaved)) {
            throw new \InvalidArgumentException('non-nullable unpaved cannot be null');
        }
        $this->container['unpaved'] = $unpaved;

        return $this;
    }

    /**
     * Gets tunnel
     *
     * @return bool|null
     */
    public function getTunnel()
    {
        return $this->container['tunnel'];
    }

    /**
     * Sets tunnel
     *
     * @param bool|null $tunnel True if the edge is a tunnel.
     *
     * @return self
     */
    public function setTunnel($tunnel)
    {
        if (is_null($tunnel)) {
            throw new \InvalidArgumentException('non-nullable tunnel cannot be null');
        }
        $this->container['tunnel'] = $tunnel;

        return $this;
    }

    /**
     * Gets bridge
     *
     * @return bool|null
     */
    public function getBridge()
    {
        return $this->container['bridge'];
    }

    /**
     * Sets bridge
     *
     * @param bool|null $bridge True if the edge is a bridge.
     *
     * @return self
     */
    public function setBridge($bridge)
    {
        if (is_null($bridge)) {
            throw new \InvalidArgumentException('non-nullable bridge cannot be null');
        }
        $this->container['bridge'] = $bridge;

        return $this;
    }

    /**
     * Gets roundabout
     *
     * @return bool|null
     */
    public function getRoundabout()
    {
        return $this->container['roundabout'];
    }

    /**
     * Sets roundabout
     *
     * @param bool|null $roundabout True if the edge is a roundabout.
     *
     * @return self
     */
    public function setRoundabout($roundabout)
    {
        if (is_null($roundabout)) {
            throw new \InvalidArgumentException('non-nullable roundabout cannot be null');
        }
        $this->container['roundabout'] = $roundabout;

        return $this;
    }

    /**
     * Gets internal_intersection
     *
     * @return bool|null
     */
    public function getInternalIntersection()
    {
        return $this->container['internal_intersection'];
    }

    /**
     * Sets internal_intersection
     *
     * @param bool|null $internal_intersection True if the edge is an internal intersection.
     *
     * @return self
     */
    public function setInternalIntersection($internal_intersection)
    {
        if (is_null($internal_intersection)) {
            throw new \InvalidArgumentException('non-nullable internal_intersection cannot be null');
        }
        $this->container['internal_intersection'] = $internal_intersection;

        return $this;
    }

    /**
     * Gets drive_on_right
     *
     * @return bool|null
     */
    public function getDriveOnRight()
    {
        return $this->container['drive_on_right'];
    }

    /**
     * Sets drive_on_right
     *
     * @param bool|null $drive_on_right True if the edge is in an area where you must drive on the right side of the road.
     *
     * @return self
     */
    public function setDriveOnRight($drive_on_right)
    {
        if (is_null($drive_on_right)) {
            throw new \InvalidArgumentException('non-nullable drive_on_right cannot be null');
        }
        $this->container['drive_on_right'] = $drive_on_right;

        return $this;
    }

    /**
     * Gets surface
     *
     * @return string|null
     */
    public function getSurface()
    {
        return $this->container['surface'];
    }

    /**
     * Sets surface
     *
     * @param string|null $surface The type of surface for the edge.
     *
     * @return self
     */
    public function setSurface($surface)
    {
        if (is_null($surface)) {
            throw new \InvalidArgumentException('non-nullable surface cannot be null');
        }
        $allowedValues = $this->getSurfaceAllowableValues();
        if (!in_array($surface, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'surface', must be one of '%s'",
                    $surface,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['surface'] = $surface;

        return $this;
    }

    /**
     * Gets sign
     *
     * @return \OpenAPI\Client\Model\EdgeSign|null
     */
    public function getSign()
    {
        return $this->container['sign'];
    }

    /**
     * Sets sign
     *
     * @param \OpenAPI\Client\Model\EdgeSign|null $sign sign
     *
     * @return self
     */
    public function setSign($sign)
    {
        if (is_null($sign)) {
            throw new \InvalidArgumentException('non-nullable sign cannot be null');
        }
        $this->container['sign'] = $sign;

        return $this;
    }

    /**
     * Gets travel_mode
     *
     * @return \OpenAPI\Client\Model\TravelMode|null
     */
    public function getTravelMode()
    {
        return $this->container['travel_mode'];
    }

    /**
     * Sets travel_mode
     *
     * @param \OpenAPI\Client\Model\TravelMode|null $travel_mode travel_mode
     *
     * @return self
     */
    public function setTravelMode($travel_mode)
    {
        if (is_null($travel_mode)) {
            throw new \InvalidArgumentException('non-nullable travel_mode cannot be null');
        }
        $this->container['travel_mode'] = $travel_mode;

        return $this;
    }

    /**
     * Gets vehicle_type
     *
     * @return string|null
     */
    public function getVehicleType()
    {
        return $this->container['vehicle_type'];
    }

    /**
     * Sets vehicle_type
     *
     * @param string|null $vehicle_type vehicle_type
     *
     * @return self
     */
    public function setVehicleType($vehicle_type)
    {
        if (is_null($vehicle_type)) {
            throw new \InvalidArgumentException('non-nullable vehicle_type cannot be null');
        }
        $allowedValues = $this->getVehicleTypeAllowableValues();
        if (!in_array($vehicle_type, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'vehicle_type', must be one of '%s'",
                    $vehicle_type,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['vehicle_type'] = $vehicle_type;

        return $this;
    }

    /**
     * Gets pedestrian_type
     *
     * @return string|null
     */
    public function getPedestrianType()
    {
        return $this->container['pedestrian_type'];
    }

    /**
     * Sets pedestrian_type
     *
     * @param string|null $pedestrian_type pedestrian_type
     *
     * @return self
     */
    public function setPedestrianType($pedestrian_type)
    {
        if (is_null($pedestrian_type)) {
            throw new \InvalidArgumentException('non-nullable pedestrian_type cannot be null');
        }
        $allowedValues = $this->getPedestrianTypeAllowableValues();
        if (!in_array($pedestrian_type, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'pedestrian_type', must be one of '%s'",
                    $pedestrian_type,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['pedestrian_type'] = $pedestrian_type;

        return $this;
    }

    /**
     * Gets bicycle_type
     *
     * @return string|null
     */
    public function getBicycleType()
    {
        return $this->container['bicycle_type'];
    }

    /**
     * Sets bicycle_type
     *
     * @param string|null $bicycle_type bicycle_type
     *
     * @return self
     */
    public function setBicycleType($bicycle_type)
    {
        if (is_null($bicycle_type)) {
            throw new \InvalidArgumentException('non-nullable bicycle_type cannot be null');
        }
        $allowedValues = $this->getBicycleTypeAllowableValues();
        if (!in_array($bicycle_type, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'bicycle_type', must be one of '%s'",
                    $bicycle_type,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['bicycle_type'] = $bicycle_type;

        return $this;
    }

    /**
     * Gets transit_type
     *
     * @return string|null
     */
    public function getTransitType()
    {
        return $this->container['transit_type'];
    }

    /**
     * Sets transit_type
     *
     * @param string|null $transit_type transit_type
     *
     * @return self
     */
    public function setTransitType($transit_type)
    {
        if (is_null($transit_type)) {
            throw new \InvalidArgumentException('non-nullable transit_type cannot be null');
        }
        $allowedValues = $this->getTransitTypeAllowableValues();
        if (!in_array($transit_type, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'transit_type', must be one of '%s'",
                    $transit_type,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['transit_type'] = $transit_type;

        return $this;
    }

    /**
     * Gets id
     *
     * @return int|null
     */
    public function getId()
    {
        return $this->container['id'];
    }

    /**
     * Sets id
     *
     * @param int|null $id id
     *
     * @return self
     */
    public function setId($id)
    {
        if (is_null($id)) {
            throw new \InvalidArgumentException('non-nullable id cannot be null');
        }
        $this->container['id'] = $id;

        return $this;
    }

    /**
     * Gets way_id
     *
     * @return int|null
     */
    public function getWayId()
    {
        return $this->container['way_id'];
    }

    /**
     * Sets way_id
     *
     * @param int|null $way_id The way identifier of the edge in OSM.
     *
     * @return self
     */
    public function setWayId($way_id)
    {
        if (is_null($way_id)) {
            throw new \InvalidArgumentException('non-nullable way_id cannot be null');
        }
        $this->container['way_id'] = $way_id;

        return $this;
    }

    /**
     * Gets weighted_grade
     *
     * @return float|null
     */
    public function getWeightedGrade()
    {
        return $this->container['weighted_grade'];
    }

    /**
     * Sets weighted_grade
     *
     * @param float|null $weighted_grade The weighted grade factor. The weighted grade is derived from elevation data. It is a measure used for hill avoidance in routing - sort of a relative energy use along an edge. But since an edge can possibly go up and down over several hills, it might not equate to what you would normally think of as grade.
     *
     * @return self
     */
    public function setWeightedGrade($weighted_grade)
    {
        if (is_null($weighted_grade)) {
            throw new \InvalidArgumentException('non-nullable weighted_grade cannot be null');
        }
        $this->container['weighted_grade'] = $weighted_grade;

        return $this;
    }

    /**
     * Gets max_upward_grade
     *
     * @return int|null
     */
    public function getMaxUpwardGrade()
    {
        return $this->container['max_upward_grade'];
    }

    /**
     * Sets max_upward_grade
     *
     * @param int|null $max_upward_grade The maximum upward slope. A value of 32768 indicates no elevation data is available for this edge.
     *
     * @return self
     */
    public function setMaxUpwardGrade($max_upward_grade)
    {
        if (is_null($max_upward_grade)) {
            throw new \InvalidArgumentException('non-nullable max_upward_grade cannot be null');
        }
        $this->container['max_upward_grade'] = $max_upward_grade;

        return $this;
    }

    /**
     * Gets max_downward_grade
     *
     * @return int|null
     */
    public function getMaxDownwardGrade()
    {
        return $this->container['max_downward_grade'];
    }

    /**
     * Sets max_downward_grade
     *
     * @param int|null $max_downward_grade The maximum downward slope. A value of 32768 indicates no elevation data is available for this edge.
     *
     * @return self
     */
    public function setMaxDownwardGrade($max_downward_grade)
    {
        if (is_null($max_downward_grade)) {
            throw new \InvalidArgumentException('non-nullable max_downward_grade cannot be null');
        }
        $this->container['max_downward_grade'] = $max_downward_grade;

        return $this;
    }

    /**
     * Gets mean_elevation
     *
     * @return int|null
     */
    public function getMeanElevation()
    {
        return $this->container['mean_elevation'];
    }

    /**
     * Sets mean_elevation
     *
     * @param int|null $mean_elevation The mean elevation along the edge. Units are meters by default. If the `units` are specified as miles, then the mean elevation is returned in feet. A value of 32768 indicates no elevation data is available for this edge.
     *
     * @return self
     */
    public function setMeanElevation($mean_elevation)
    {
        if (is_null($mean_elevation)) {
            throw new \InvalidArgumentException('non-nullable mean_elevation cannot be null');
        }
        $this->container['mean_elevation'] = $mean_elevation;

        return $this;
    }

    /**
     * Gets lane_count
     *
     * @return int|null
     */
    public function getLaneCount()
    {
        return $this->container['lane_count'];
    }

    /**
     * Sets lane_count
     *
     * @param int|null $lane_count The number of lanes for this edge.
     *
     * @return self
     */
    public function setLaneCount($lane_count)
    {
        if (is_null($lane_count)) {
            throw new \InvalidArgumentException('non-nullable lane_count cannot be null');
        }
        $this->container['lane_count'] = $lane_count;

        return $this;
    }

    /**
     * Gets cycle_lane
     *
     * @return string|null
     */
    public function getCycleLane()
    {
        return $this->container['cycle_lane'];
    }

    /**
     * Sets cycle_lane
     *
     * @param string|null $cycle_lane The type of cycle lane (if any) along this edge.
     *
     * @return self
     */
    public function setCycleLane($cycle_lane)
    {
        if (is_null($cycle_lane)) {
            throw new \InvalidArgumentException('non-nullable cycle_lane cannot be null');
        }
        $allowedValues = $this->getCycleLaneAllowableValues();
        if (!in_array($cycle_lane, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'cycle_lane', must be one of '%s'",
                    $cycle_lane,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['cycle_lane'] = $cycle_lane;

        return $this;
    }

    /**
     * Gets bicycle_network
     *
     * @return int|null
     */
    public function getBicycleNetwork()
    {
        return $this->container['bicycle_network'];
    }

    /**
     * Sets bicycle_network
     *
     * @param int|null $bicycle_network The type of bicycle network, if any. This is an integer comprised of constants bitwise or'd together. For example, a route that's part of both a local and mountain network would have a value of 12. 1 - National 2 - Regional 4 - Local 8 - Mountain
     *
     * @return self
     */
    public function setBicycleNetwork($bicycle_network)
    {
        if (is_null($bicycle_network)) {
            throw new \InvalidArgumentException('non-nullable bicycle_network cannot be null');
        }
        $this->container['bicycle_network'] = $bicycle_network;

        return $this;
    }

    /**
     * Gets sac_scale
     *
     * @return int|null
     */
    public function getSacScale()
    {
        return $this->container['sac_scale'];
    }

    /**
     * Sets sac_scale
     *
     * @param int|null $sac_scale The difficulty of the hiking trail according to the SAC scale. 0 - No Sac Scale 1 - Hiking 2 - Mountain hiking 3 - Demanding mountain hiking 4 - Alpine hiking 5 - Demanding alpine hiking 6 - Difficult alpine hiking
     *
     * @return self
     */
    public function setSacScale($sac_scale)
    {
        if (is_null($sac_scale)) {
            throw new \InvalidArgumentException('non-nullable sac_scale cannot be null');
        }
        $this->container['sac_scale'] = $sac_scale;

        return $this;
    }

    /**
     * Gets sidewalk
     *
     * @return string|null
     */
    public function getSidewalk()
    {
        return $this->container['sidewalk'];
    }

    /**
     * Sets sidewalk
     *
     * @param string|null $sidewalk sidewalk
     *
     * @return self
     */
    public function setSidewalk($sidewalk)
    {
        if (is_null($sidewalk)) {
            throw new \InvalidArgumentException('non-nullable sidewalk cannot be null');
        }
        $allowedValues = $this->getSidewalkAllowableValues();
        if (!in_array($sidewalk, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'sidewalk', must be one of '%s'",
                    $sidewalk,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['sidewalk'] = $sidewalk;

        return $this;
    }

    /**
     * Gets density
     *
     * @return int|null
     */
    public function getDensity()
    {
        return $this->container['density'];
    }

    /**
     * Sets density
     *
     * @param int|null $density density
     *
     * @return self
     */
    public function setDensity($density)
    {
        if (is_null($density)) {
            throw new \InvalidArgumentException('non-nullable density cannot be null');
        }
        $this->container['density'] = $density;

        return $this;
    }

    /**
     * Gets speed_limit
     *
     * @return mixed|null
     */
    public function getSpeedLimit()
    {
        return $this->container['speed_limit'];
    }

    /**
     * Sets speed_limit
     *
     * @param mixed|null $speed_limit The speed limit along the edge measured in `units`/hr. This may be either an integer or the string \"unlimited\" if speed limit data is available. If absent, there is no speed limit data available.
     *
     * @return self
     */
    public function setSpeedLimit($speed_limit)
    {
        if (is_null($speed_limit)) {
            array_push($this->openAPINullablesSetToNull, 'speed_limit');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('speed_limit', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['speed_limit'] = $speed_limit;

        return $this;
    }

    /**
     * Gets truck_speed
     *
     * @return int|null
     */
    public function getTruckSpeed()
    {
        return $this->container['truck_speed'];
    }

    /**
     * Sets truck_speed
     *
     * @param int|null $truck_speed The truck speed of this edge in `units`/hr, in terms of average/free-flow speed for routing purposes. This is affected by any number of factors such as the road service, vehicle type, etc. and not just the posted speed limits.
     *
     * @return self
     */
    public function setTruckSpeed($truck_speed)
    {
        if (is_null($truck_speed)) {
            throw new \InvalidArgumentException('non-nullable truck_speed cannot be null');
        }
        $this->container['truck_speed'] = $truck_speed;

        return $this;
    }

    /**
     * Gets truck_route
     *
     * @return bool|null
     */
    public function getTruckRoute()
    {
        return $this->container['truck_route'];
    }

    /**
     * Sets truck_route
     *
     * @param bool|null $truck_route True if the edge is part of a truck route/network.
     *
     * @return self
     */
    public function setTruckRoute($truck_route)
    {
        if (is_null($truck_route)) {
            throw new \InvalidArgumentException('non-nullable truck_route cannot be null');
        }
        $this->container['truck_route'] = $truck_route;

        return $this;
    }

    /**
     * Gets end_node
     *
     * @return \OpenAPI\Client\Model\EndNode|null
     */
    public function getEndNode()
    {
        return $this->container['end_node'];
    }

    /**
     * Sets end_node
     *
     * @param \OpenAPI\Client\Model\EndNode|null $end_node end_node
     *
     * @return self
     */
    public function setEndNode($end_node)
    {
        if (is_null($end_node)) {
            throw new \InvalidArgumentException('non-nullable end_node cannot be null');
        }
        $this->container['end_node'] = $end_node;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


